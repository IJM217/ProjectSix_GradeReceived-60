treats <- rep(c("MS", "MDS", "MP", "MDP") each = 2)
treats <- rep(c("MS", "MDS", "MP", "MDP"), each = 2)
sample(treats)
treats <- rep(c("MS", "MDS", "MP", "MDP"), each = 1)
sample(treats)
treats <- rep(c("MS", "MDS", "MP", "MDP"), each = 2)
ex <- rep(c("A", "B", "C", "D"), each = 2)
sample(treats)
sample(ex)
ex <- rep(c("A", "B", "C", "D"), each = 1)
treats <- rep(c("MS", "MDS", "MP", "MDP"), each = 1)
sample(treats)
print(ex)
sample(treats)
print(ex)
serial <- c(2.431,9.134,16.120,86.172)  # Execution times for serial execution
parallel <- c(1.337,3.380,6.375,13.004)   # Execution times for parallel execution
# Calculate means and standard deviations for each group
mean_serial <- mean(serial)
mean_parallel <- mean(parallel)
sd_serial <- sd(serial)
sd_parallel <- sd(parallel)
# Compute pooled standard deviation
pooled_sd <- sqrt(((sd_serial^2 + sd_parallel^2) / 2))
# Compute Cohen's d
cohen_d <- (mean_serial - mean_parallel) / pooled_sd
# Print Cohen's d
print(cohen_d)
library(pwr)
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.99, type = "two.sample")
sample(treats)
sample(treats)
sample(treats)
sample(treats)
sample(treats)
sample(treats)
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 1, type = "two.sample")
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.99, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.80, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.90, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.85, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.88, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.87, type = "two.sample")
pilot <- read.csv("Exp1.csv")
View(pilot)
plot(ExTime~CWork + Type, data = pilot)
plot(ExTime~CWork + Type, data = pilot)
plot(ExTime~CWork + Type, data = pilot)
plot(ExTime~CWork*Type, data = pilot)
plot(ExTime~CWork+Type+CWork:Type, data = pilot)
plot(ExTime~CWork+Type+CWork:Type, data = pilot)
str(pilot)
library(ggplot2)
# Convert Type to a factor
pilot$Type <- factor(pilot$Type, levels = c("Sequential", "Parallel"))
ggplot(pilot, aes(x = CWork, y = ExTime, color = Type, group = Type)) +
geom_line() +
geom_point() +
labs(x = "Computational Work", y = "Execution Time", color = "Execution Type") +
theme_minimal()
plot(ExTime~CWork+Type+CWork:Type, data = pilot)
plot(ExTime~Type, data = pilot)
m1 <- lm(ExTime~Type, data = pilot)
summary(m1)
real <- read.csv("Exp2.csv")
str(real)
real$Type <- factor(real$Type, levels = c("Sequential", "Parallel"))
plot(ExTime~Type, data = real)
ggplot(real, aes(x = CWork, y = ExTime, color = Type, group = Type)) +
geom_line() +
geom_point() +
labs(x = "Computational Work", y = "Execution Time", color = "Execution Type") +
theme_minimal()
library(ggplot2)
ggplot(real, aes(x = CWork, y = ExTime, color = Type, group = Type)) +
geom_line() +
geom_point() +
labs(x = "Computational Work", y = "Execution Time", color = "Execution Type") +
theme_minimal()
ggplot(real, aes(x = CWork, y = ExTime, color = Type, linetype = Algorithm, group = interaction(Type, Algorithm))) +
geom_line() +
geom_point() +
labs(x = "Computational Work", y = "Execution Time", color = "Execution Type", linetype = "Algorithm") +
theme_minimal()
ggplot(real, aes(x = CWork, y = ExTime, color = Type, linetype = Algo, group = interaction(Type, Algo))) +
geom_line() +
geom_point() +
labs(x = "Computational Work", y = "Execution Time", color = "Execution Type", linetype = "Algorithm") +
theme_minimal()
library(pwr)
library(ggplot2)
real <- read.csv("Exp2.csv")
str(real)
real$Type <- factor(real$Type, levels = c("Sequential", "Parallel"))
plot(ExTime~Type, data = real)
ggplot(real, aes(x = CWork, y = ExTime, color = Type, linetype = Algo, group = interaction(Type, Algo))) +
geom_line() +
geom_point() +
labs(x = "Computational Work", y = "Execution Time", color = "Execution Type", linetype = "Algorithm") +
theme_minimal()
bp <- plot(ExTime~Type, data = real)
print(bp)
summary(bp)
bp <- plot(ExTime~Type, data = real)
bp <- boxplot(ExTime~Type, data = real)
boxplot(ExTime ~ Type, data = real,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Execution Type")
boxplot(ExTime ~ Type, data = real,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
summary(bp)
print(bp)
boxplot(ExTime ~ Type, data = real,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type"
outline = FALSE)
bp <- boxplot(ExTime ~ Type, data = real,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type",
outline = FALSE)
print(bp)
rm(bp)
bp <- boxplot(ExTime ~ Type, data = real,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type",
outline = FALSE)
print(bp)
summary(bp)
m1 <- t.test(ExTime ~ Type, data = real)
print(m1)
View(real)
summary(m1)
plot(m1)
hist(resid(m1))
res <- residuals(m1)
m2 <- aov(ExTime ~ Type, data = real)
summary.aov(m2)
plot(m2)
bp <- boxplot(ExTime ~ Type, data = real,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
hist(res(m2))
hist(resid(m2))
mean_parallel <- mean(df$ExTime[df$Type == "Parallel"], data = real)
mean_parallel <- mean(real$ExTime[real$Type == "Parallel"])
# Calculate the mean for Sequential execution
mean_sequential <- mean(real$ExTime[real$Type == "Sequential"])
# Print the means
cat("Mean for Parallel execution:", mean_parallel, "\n")
cat("Mean for Sequential execution:", mean_sequential, "\n")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.80, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.82, type = "two.sample")
real_subset <- real[1:(nrow(real) - 8), ]
m1 <- t.test(ExTime ~ Type, data = real_subset)
print(m1)
summary(m1)
View(real_subset)
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[1:(nrow(real) - 12), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(8 + 1):nrow(real), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(9 + 1):nrow(real), ]
real_subset <- real[(12 + 1):nrow(real), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
m1 <- t.test(ExTime ~ Type, data = real_subset)
print(m1)
summary(m1)
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.82, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.80, type = "two.sample")
real_subset <- real[(10 + 1):nrow(real), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(12 + 1):nrow(real), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(8 + 1):(nrow(real) - 2), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(10 + 1):nrow(real), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(8 + 1):(nrow(real) - 2), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(8 + 1):(nrow(real) - 1), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(9 + 1):(nrow(real) - 1), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(4 + 1):(nrow(real) - 4), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(8 + 1):(nrow(real) - 2), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(9 + 1):(nrow(real) - 1), ]
m1 <- t.test(ExTime ~ Type, data = real_subset)
print(m1)
summary(m1)
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(10 + 1):(nrow(real)), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(10 + 1):(nrow(real)-1), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
real_subset <- real[(12 + 1):(nrow(real)), ]
boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.799, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.8, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.78, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.79, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.795, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.794, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.793, type = "two.sample")
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.792, type = "two.sample")
m3 <- aov(ExTime ~ Type, data = real_subset)
m3
m2
summary.aov(m3)
plot(m3)
m1 <- t.test(ExTime ~ Type, data = real_subset)
print(m1)
m1
ex <- rep(c("A", "B", "C", "D"), each = 1)
print(ex)
treats <- rep(c("MS", "MDS", "MP", "MDP"), each = 1)
sample(treats)
ex <- rep(c("A", "B", "C", "D"), each = 1)
print(ex)
#randomly assign
ex <- rep(c("A", "B", "C", "D"), each = 1)
print(ex)
treats <- rep(c("MS", "MDS", "MP", "MDP"), each = 1)
sample(treats)
serial <- c(2.431,9.134,16.120,86.172)  # Execution times for serial execution
parallel <- c(1.337,3.380,6.375,13.004)   # Execution times for parallel execution
# Calculate means and standard deviations for each group
mean_serial <- mean(serial)
mean_parallel <- mean(parallel)
sd_serial <- sd(serial)
sd_parallel <- sd(parallel)
# Compute pooled standard deviation
pooled_sd <- sqrt(((sd_serial^2 + sd_parallel^2) / 2))
# Compute Cohen's d
cohen_d <- (mean_serial - mean_parallel) / pooled_sd
serial <- c(2.431,9.134,16.120,86.172)  # Execution times for serial execution
parallel <- c(1.337,3.380,6.375,13.004)   # Execution times for parallel execution
# Calculate means and standard deviations for each group
mean_serial <- mean(serial)
mean_parallel <- mean(parallel)
sd_serial <- sd(serial)
sd_parallel <- sd(parallel)
# Compute pooled standard deviation
pooled_sd <- sqrt(((sd_serial^2 + sd_parallel^2) / 2))
# Compute Cohen's d
cohen_d <- (mean_serial - mean_parallel) / pooled_sd
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.87, type = "two.sample")
real_subset <- real[(12 + 1):(nrow(real)), ]
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.792, type = "two.sample")
m1 <- t.test(ExTime ~ Type, data = real_subset)
print(m1)
m2 <- aov(ExTime ~ Type, data = real)
summary.aov(m2)
m2
Print(boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type"))
Bp2 <-(boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
summary(Bp2)
p2 <-(boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time")
summary(Bp2)
Bp2 <-(boxplot(ExTime ~ Type, data = real_subset, xlab = "Execution Type", ylab = "Execution Time")
summary(Bp2)
Bp2
Bp2 <-(boxplot(ExTime ~ Type, data = real_subset, xlab = "Execution Type", ylab = "Execution Time")
print(Bp2)
Bp2 <-(boxplot(ExTime ~ Type, data = real_subset)
Bp2 <-(boxplot(ExTime ~ Type, data = real_subset,
Bp2 <-boxplot(ExTime ~ Type, data = real,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
summary(Bp2)
Bp2 <-boxplot(ExTime ~ Type, data = real_subset,
xlab = "Execution Type",
ylab = "Execution Time",
main = "Execution Time by Program Type")
summary(Bp2)
serial <- c(2.431,9.134,16.120,86.172)  # Execution times for serial execution
parallel <- c(1.337,3.380,6.375,29.914)   # Execution times for parallel execution
# Calculate means and standard deviations for each group
mean_serial <- mean(serial)
mean_parallel <- mean(parallel)
sd_serial <- sd(serial)
sd_parallel <- sd(parallel)
# Compute pooled standard deviation
pooled_sd <- sqrt(((sd_serial^2 + sd_parallel^2) / 2))
# Compute Cohen's d
cohen_d <- (mean_serial - mean_parallel) / pooled_sd
#power analyses for no. of replicates
pwr.t.test(d = cohen_d, sig.level = 0.05, power = 0.87, type = "two.sample")
